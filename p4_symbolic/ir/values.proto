// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file defines the protobuf structure of a bmv2 "Value".
// This construct corresponds to a "Type-Value object" in the JSON format.
// https://github.com/p4lang/behavioral-model/blob/master/docs/JSON_format.md#the-type-value-object
// The value defined may either be an LValue or an RValue.
//
// This is not a comprehensive definition, several types are unsupported here.
// The complete list can be found at:
// https://github.com/p4lang/behavioral-model/blob/master/docs/JSON_format.md#the-type-value-object
// In Particular, these definitions do not support registers, local array
// indexing, parameters vectors, named calculations, lookaheads, externs,
// and header stacks and unions.

syntax = "proto3";

package p4_symbolic.ir;

// The valid operations making up an RValue.
enum RValueOpEnum {
  rvalue_op_field = 0;
  rvalue_op_hexstr = 1;
  rvalue_op_bool_ = 2;
  rvalue_op_string_ = 3;
  rvalue_op_variable = 4;
  rvalue_op_expression = 5;
}

// The valid operations making up an LValue.
enum LValueOpEnum {
  lvalue_op_field = 0;
  lvalue_op_variable = 1;
  lvalue_op_expression = 2;
}

// The structure of an abstract RValue.
message RValue {
  RValueOpEnum op = 1;
  oneof rvalue {
    FieldValue field_value = 2;
    HexstrValue hexstr_value = 3;
    BoolValue bool_value = 4;
    StringValue string_value = 5;
    Variable variable = 6;
    RExpression expression = 7;
  }
}

// The structure of an abstract LValue.
message LValue {
  LValueOpEnum op = 1;
  oneof lvalue {
    FieldValue field_value = 2;
    Variable variable = 3;
    LExpression expression = 4;
  }
}

//
// Below are concrete definitions of each conrete type of values.
//

// A header field accessed statically.
// Field access that is dynamic (either in the index/offset or in the header
// object) is defined under AccessExpression below.
message FieldValue {
  string header_name = 1;
  string field_name = 2;
}

// Corresponds to a hex bigendiean encoding of a bit-string.
// In the bmv2 JSON format. The hexstring can be prefixed by "-"
// for negative values.
// We remove any such prefix and explicitly set the negative flag.
message HexstrValue {
  string value = 1;
  bool negative = 2;
}

// A boolean literal value.
message BoolValue {
  bool value = 1;
}

// A string literal value.
message StringValue {
  string value = 1;
}

// Our explicit representation of a runtime variable.
// The bmv2 JSON format represents variables as indices
// to a runtime_data array in the enclosing scope, which
// contains the variable name.
// We directly refer to variables by their name.
message Variable {
  string name = 1;
}

//
// Below are all things expressions, starting with abstract RExpression and
// LExpression, and ending with concrete expression type definitions.
//

// Possible rexpressions.
enum RExpressionOpEnum {
  rexpression_op_simple_binary = 0;
  rexpression_op_simple_unary = 1;
  rexpression_op_conversion = 2;
  rexpression_op_ternary = 3;
  rexpression_op_stack = 4;
  rexpression_op_access = 5;
}

// Possible lexpressions.
enum LExpressionOpEnum {
  // Only includes (dynamic) access expressions for now.
  lexpression_op_access = 0;
}

// An abstract RExpression.
message RExpression {
  RExpressionOpEnum op = 1;
  oneof expression {
    SimpleBinaryExpression simple_binary_expression = 2;
    SimpleUnaryExpression simple_unary_expression = 3;
    ConversionExpression conversion_expression = 4;
    TernaryExpression ternary_expression = 5;
    StackExpression stack_expression = 6;
    AccessExpression access_expression = 7;
  }
}

// An abstract LExpression.
message LExpression {
  LExpressionOpEnum op = 1;
  oneof expression {
    AccessExpression access_expression = 2;
  }
}

// TODO(babman): turn op in what follows to enums.

// Arithmetic, relational, and boolean binary operations.
message SimpleBinaryExpression {
  // One of: +, -, *, <<, >>, ==, !=, >, >=, <, <=,
  // "and", "or", "&", "|", "^", "two_comp_mod" (2-complement modulo).
  string op = 1;
  RExpression left = 2;
  RExpression right = 3;
}

// Arithmetic and boolean unary operations.
message SimpleUnaryExpression {
  // One of: "not" (boolean not), ~ (binary not), "valid", "valid_union".
  string op = 1;
  RExpression operand = 2;
}

// Conversions and casts between data types.
message ConversionExpression {
  // One of: "d2b" (data-2-bool), "b2d" (bool-to-data)", "sat_cast" (saturating
  // cast for signed integers), "unsat_cast" (saturating cast for unsigned
  // integers).
  string op = 1;
  RExpression operand = 2;
}

// Ternary condition on the form <condition> ? <left> : <right>.
message TernaryExpression {
  RExpression condition = 1;
  RExpression left = 2;
  RExpression right = 3;
}

// Unary expressions on stacks (size and indicies).
message StackExpression {
  // One of "last_stack_index" or "size_stack", which
  // give the last valid index and the size of a stack.
  string op = 1;
  RExpression stack = 2;
}

// Dynamic access expressions.
// The access may be dynamic in the index. For example, when the index is an
// arithmetic expression.
// The access may also be dynamic in the accessor, i.e. the header
// or stack being accessed is determined at runtime by a dynamic expression.
message AccessExpression {
  // Type of access.
  // One of:
  //   "dereference_header_stack": access a header_stack at an index.
  //   "access_field": access a dynamically specified header at an offset.
  //   "dereference_union_stack": access a header_union_stack at an index.
  //   "access_union_header": access a dynamically specified a header_union at
  //                          an offset.
  // https://github.com/p4lang/behavioral-model/blob/master/docs/JSON_format.md#the-type-value-object
  string op = 1;
  RExpression accessor = 2;
  RExpression index = 3;
}
